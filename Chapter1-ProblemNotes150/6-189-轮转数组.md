# <font color = 'orange'> 中等 </font>   

`数组`, `双指针`

该题有3种方法：

1. `额外数组`。对于第`i`个元素，其轮转后应该位于第`(i + k) % n`个元素。在轮转第`(i + k) % n`个元素的时候，因为第`i`个元素的轮转会覆盖第(i + k) % n个元素。因此，可以采用一个额外的数组`memo`用来存储轮转后的元素。这样先轮转的元素就不会覆盖掉后面的元素了。最后再用memo覆盖nums，实现原地修改。
    <br><br>
    时间复杂度：$O(n)$
    <br><br>
    空间复杂度：$O(n)$
<br><br>
2.  `临时变量`。在方法1中，可以发现遍历过程中，每个元素只轮转一次，意味着每个元素轮转只会产生一次覆盖。同时每个元素轮转一次后就可以确定最终的位置。因此，整个轮转过程中会产生n次覆盖。在顺序遍历$nums$过程中，$nums[i_m]$会覆盖$nums[(i_m + k) % n]$。因此可以设置一个变量$temp$，用于存储$nums[(i_m + k) % n]$。如果此时按顺序访问$nums[i_m + 1]$，那么$nums[(i_m + 1 + k) % n]$会被覆盖，为了防止被覆盖，$temp$需要被更新为$nums[(i_m + 1 + k) % n]$，这就导致$nums[(i_m + k) % n]$的原始值丢失了。因此在遍历完$nums[i_m]$，下一次遍历$nums[(i_m + k) % n]$。不妨设$i_{m+1} = (i_m + k) % n$。对于$nums[i_{m + 1}]$，会覆盖$nums[(i_{m+1} + k ) % n]$。此时$nums[i_{m + 1}]$的值存储在$temp$中，$nums[(i_{m + 1} + k ) % n]$也需要向$temp$中复制自己原始的值，交换$temp$和$ums[(i_{m + 1} + k ) % n]$即可满足两者的要求。然后令$i_{m + 2} = (i_{m + 1} + 1) % n$，开始新一轮的循环。
    <br><br>
    按照上述循环过程，可能会有$i_m = i_{n}(m < n)$，但此时可能并没有遍历到$nums$中的每一个元素。此时应该令$i_{n + 1} = (i_n + k + 1) % n$，向右偏移一个元素，这样最终会有$i_m + 1 = i_{n + 1}(m < n )$，然后再偏移一个元素。当偏移$k - 1$个元素。能保证遍历到所有的元素了。事实上，当$i_m = i_{n}(m < n)$时，遍历了整数圈，假设为$a$圈，总共访问了$b$个元素，有$an = bk$。第一次回到起点时，$an = lcm(n, k)$，因此在不改变偏移下能访问到$\frac{lcm(n,k)}{k}$个元素。为了访问到所有的元素，有
    $$\frac{n}{\frac{lcm(n,k)}{k}} = \frac{nk}{lcm(n,k)} = gcd(n,k)$$
    因此实际上只需要偏移$gcd(n,k)$次即可。或者统计当前轮转了$count$个元素，由于每个元素有且仅有一次轮转，因此当$count = n$时，也能表明此时访问了$nums$中的所有元素。
    <br><br>
    上述循环过程已经建立，考虑初始和结束状态。初始状态令$temp = nums[0]$，满足循环的条件：$temp$中是上一轮循环中$nums$中的原始值。结束状态，由于每个元素都被遍历到且被轮转了，因此$nums$是经过轮转的数组。